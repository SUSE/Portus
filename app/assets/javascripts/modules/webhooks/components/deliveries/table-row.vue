<template>
  <tr :class="scopeClass">
    <td>
      <i :class="statusIcon"></i>
      {{ delivery.uuid }}
    </td>
    <td>{{ updatedAt }}</td>
    <td v-if="webhook.updatable">
      <button class="btn btn-default delete-webhook-btn"
        @click="retrigger"
        v-if="webhook.enabled">
        <i class="fa fa-refresh" :class="{'fa-spin': ongoingRequest}"></i>
      </button>
      <popover title="Please confirm" placement="left" v-model="confirm" v-else>
        <button class="btn btn-default" role="button" :disabled="ongoingRequest">
          <i class="fa fa-refresh" :class="{'fa-spin': ongoingRequest}"></i>
        </button>
        <template slot="popover">
          <div class='popover-content'>
            <p>This webhook is disabled. Are you sure you want to retrigger it?</p>
            <a class='btn btn-default' @click="confirm = false">No</a>
            <a class='btn btn-primary yes' @click="retrigger">Yes</a>
          </div>
        </template>
      </popover>
    </td>
  </tr>
</template>

<script>
  import Vue from 'vue';
  import dayjs from 'dayjs';

  import { handleHttpResponseError } from '~/utils/http';

  import { Popover } from 'uiv';
  import WebhookDeliveriesService from '../../services/deliveries';

  const { set } = Vue;

  export default {
    props: ['delivery', 'webhook'],

    data() {
      return {
        ongoingRequest: false,
        confirm: false,
      };
    },

    computed: {
      scopeClass() {
        return `webhook_delivery_${this.delivery.id}`;
      },

      statusIcon() {
        if (this.delivery.status === 200) {
          return 'fa fa-check fa-lg text-success';
        }

        return 'fa fa-close fa-lg text-danger';
      },

      updatedAt() {
        return dayjs(this.delivery.updated_at).fromNow();
      },
    },

    methods: {
      retrigger() {
        const namespaceId = this.webhook.namespace_id;
        const webhookId = this.webhook.id;
        const { id } = this.delivery;

        set(this, 'ongoingRequest', true);
        WebhookDeliveriesService.retrigger(namespaceId, webhookId, id).then((response) => {
          const delivery = response.data;

          this.$bus.$emit('deliveryRetriggered', delivery);
          this.$alert.$show(`Delivery '${this.delivery.uuid}' was retriggered successfully`);
        }).catch(handleHttpResponseError)
          .finally(() => set(this, 'ongoingRequest', false));
      },
    },

    components: {
      Popover,
    },
  };
</script>
